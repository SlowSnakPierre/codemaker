"use client";

import { useState, useEffect, useCallback, useRef } from "react";
import {
	FolderIcon,
	FileIcon,
	ChevronDownIcon,
	ChevronRightIcon,
	RefreshCwIcon,
	PlusIcon,
	FilePlusIcon,
	FolderPlusIcon,
	ImageIcon,
	FileTextIcon,
	FileCodeIcon,
	FileCogIcon,
	Code2Icon,
	CogIcon,
} from "lucide-react";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Button } from "@/components/ui/button";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { FileData, FileChangeEvent } from "@/lib/types";
import { getFileIcon, getFileIconColor } from "@/lib/file-icons";
import { toast } from "sonner";

interface SidebarProps {
	currentDirectory: string | null;
	onFileSelect: (file: FileData) => void;
	onDirectoryOpen: () => void;
}

export default function Sidebar({
	currentDirectory,
	onFileSelect,
	onDirectoryOpen,
}: SidebarProps) {
	const [files, setFiles] = useState<FileData[]>([]);
	const [expandedFolders, setExpandedFolders] = useState<
		Record<string, boolean>
	>({});
	const [isCreatingFile, setIsCreatingFile] = useState<boolean>(false);
	const [isCreatingFolder, setIsCreatingFolder] = useState<boolean>(false);
	const [newFileName, setNewFileName] = useState<string>("");
	const [newFolderName, setNewFolderName] = useState<string>("");
	const [selectedFolder, setSelectedFolder] = useState<string | null>(null);
	const [isLoading, setIsLoading] = useState<boolean>(false);
	const [activeFilePath, setActiveFilePath] = useState<string | null>(null);

	// Reference to track if component is mounted
	const isMounted = useRef(true);

	const isElectron = typeof window !== "undefined" && window.electron;

	useEffect(() => {
		// Set mount state
		isMounted.current = true;

		// Cleanup on unmount
		return () => {
			isMounted.current = false;
			if (isElectron) {
				window.electron.off("fs:fileChanged");
			}
		};
	}, [isElectron]);

	// Setup file change listener
	useEffect(() => {
		if (isElectron && currentDirectory) {
			window.electron.on("fs:fileChanged", handleFileChange);
		}

		return () => {
			if (isElectron) {
				window.electron.off("fs:fileChanged");
			}
		};
	}, [isElectron, currentDirectory, files]);

	// Load initial directory content
	useEffect(() => {
		if (currentDirectory && isElectron) {
			setIsLoading(true);
			loadDirectoryContents(currentDirectory).finally(() => {
				if (isMounted.current) {
					setIsLoading(false);
				}
			});
		}
	}, [currentDirectory, isElectron]);

	// Handle file changes (add, delete, etc.)
	const handleFileChange = async (event: FileChangeEvent) => {
		if (!currentDirectory) return;

		// If path is not in current directory, ignore
		if (!event.path.startsWith(currentDirectory)) return;

		// Determine parent directory of modified file
		const dirPath = event.path
			.split(/[\/\\]/)
			.slice(0, -1)
			.join("/");

		// Refresh parent directory
		if (isElectron) {
			const result = await window.electron.refreshDirectory(dirPath);
			if (result.success) {
				updateFilesTree(dirPath, result.files || []);
			}
		}
	};

	// Update file tree with new data
	const updateFilesTree = (dirPath: string, newContents: FileData[]) => {
		// If it's the main directory
		if (dirPath === currentDirectory) {
			setFiles(newContents);
			return;
		}

		// Otherwise, update specific subdirectory
		setFiles((prevFiles) => {
			return updateNestedFilesWithChildren(
				prevFiles,
				dirPath,
				newContents
			);
		});
	};

	// Recursive function to update nested tree
	const updateNestedFilesWithChildren = (
		files: FileData[],
		targetPath: string,
		newChildren: FileData[]
	): FileData[] => {
		return files.map((file) => {
			if (file.path === targetPath) {
				return { ...file, children: newChildren };
			} else if (file.children) {
				return {
					...file,
					children: updateNestedFilesWithChildren(
						file.children,
						targetPath,
						newChildren
					),
				};
			}
			return file;
		});
	};

	// Load directory content
	const loadDirectoryContents = async (dirPath: string) => {
		try {
			if (!isElectron) return;

			const contents = await window.electron.readDirectory(dirPath);
			if (!contents) throw new Error("No content found");

			if (dirPath === currentDirectory) {
				setFiles(contents);
			}

			return contents;
		} catch (error) {
			console.error("Failed to read directory:", error);
			toast.error("Unable to read folder content");
		}
	};

	// Explicitly refresh a folder
	const refreshFolder = async (path: string) => {
		if (!isElectron) return;

		setIsLoading(true);
		try {
			const result = await window.electron.refreshDirectory(path);
			if (result.success) {
				updateFilesTree(path, result.files || []);
				toast.success("Folder refreshed successfully");
			} else {
				toast.error(`Error refreshing: ${result.message}`);
			}
		} catch (error) {
			console.error("Refresh failed:", error);
			toast.error("Unable to refresh folder");
		} finally {
			setIsLoading(false);
		}
	};

	// Toggle folder expansion state
	const toggleFolder = useCallback((path: string) => {
		setExpandedFolders((prev) => {
			const newState = { ...prev };
			newState[path] = !prev[path];
			return newState;
		});
	}, []);

	// Handle folder click
	const handleFolderClick = async (path: string) => {
		if (!expandedFolders[path] && isElectron) {
			setIsLoading(true);
			try {
				const contents = await window.electron.readDirectory(path);
				if (!contents) throw new Error("No content found");

				setFiles((prevFiles) => {
					return updateFilesWithChildren(prevFiles, path, contents);
				});
			} catch (error) {
				console.error("Failed to read directory:", error);
				toast.error("Unable to read folder content");
			} finally {
				setIsLoading(false);
			}
		}
		toggleFolder(path);
	};

	// Update file tree with children
	const updateFilesWithChildren = (
		files: FileData[],
		targetPath: string,
		children: FileData[]
	): FileData[] => {
		return files.map((file) => {
			if (file.path === targetPath) {
				return { ...file, children };
			} else if (file.children) {
				return {
					...file,
					children: updateFilesWithChildren(
						file.children,
						targetPath,
						children
					),
				};
			}
			return file;
		});
	};

	// Create new file
	const handleCreateFile = async () => {
		if (!selectedFolder || !isElectron || !newFileName.trim()) return;

		setIsLoading(true);
		try {
			const result = await window.electron.createFile({
				dirPath: selectedFolder,
				fileName: newFileName.trim(),
			});

			if (result.success) {
				// Update tree with new file
				refreshFolder(selectedFolder);
				toast.success(`File "${newFileName}" created successfully`);
				setNewFileName("");
				setIsCreatingFile(false);
			} else {
				toast.error(`Error creating file: ${result.message}`);
			}
		} catch (error) {
			console.error("Failed to create file:", error);
			toast.error("Unable to create file");
		} finally {
			setIsLoading(false);
		}
	};

	// Create new folder
	const handleCreateFolder = async () => {
		if (!selectedFolder || !isElectron || !newFolderName.trim()) return;

		setIsLoading(true);
		try {
			const result = await window.electron.createDirectory({
				dirPath: selectedFolder,
				folderName: newFolderName.trim(),
			});

			if (result.success) {
				// Update tree with new folder
				refreshFolder(selectedFolder);
				toast.success(`Folder "${newFolderName}" created successfully`);
				setNewFolderName("");
				setIsCreatingFolder(false);
			} else {
				toast.error(`Error creating folder: ${result.message}`);
			}
		} catch (error) {
			console.error("Failed to create folder:", error);
			toast.error("Unable to create folder");
		} finally {
			setIsLoading(false);
		}
	};

	// Handle file click
	const handleFileClick = (file: FileData) => {
		setActiveFilePath(file.path);
		onFileSelect(file);
	};

	// Choose appropriate icon for a file
	const renderFileIcon = (fileName: string) => {
		const iconType = getFileIcon(fileName);
		const iconColor = getFileIconColor(fileName);

		switch (iconType) {
			case "image":
				return <ImageIcon className={`h-4 w-4 ${iconColor}`} />;
			case "file-text":
				return <FileTextIcon className={`h-4 w-4 ${iconColor}`} />;
			case "file-code":
				return <FileCodeIcon className={`h-4 w-4 ${iconColor}`} />;
			case "file-css":
				return <FileCogIcon className={`h-4 w-4 ${iconColor}`} />;
			case "file-js":
				return <Code2Icon className={`h-4 w-4 ${iconColor}`} />;
			case "file-json":
				return <FileCogIcon className={`h-4 w-4 ${iconColor}`} />;
			case "file-config":
				return <CogIcon className={`h-4 w-4 ${iconColor}`} />;
			default:
				return <FileIcon className={`h-4 w-4 ${iconColor}`} />;
		}
	};

	// Recursively render folder items
	const renderFolderItems = (items: FileData[], level = 0) => {
		return items.map((item) => {
			const isExpanded = expandedFolders[item.path] || false;
			const isActive = activeFilePath === item.path;
			const indent = level * 8;

			if (item.isDirectory) {
				return (
					<div key={item.path} className="folder-container">
						<div
							className={`group flex items-center h-6 cursor-pointer hover:bg-neutral-800/40 ${
								isExpanded ? "bg-neutral-800/20" : ""
							}`}
							onClick={() => handleFolderClick(item.path)}
							style={{ paddingLeft: `${indent}px` }}
						>
							<span className="flex items-center justify-center w-6 text-neutral-500">
								{isExpanded ? (
									<ChevronDownIcon className="h-4 w-4" />
								) : (
									<ChevronRightIcon className="h-4 w-4" />
								)}
							</span>
							<FolderIcon className="h-4 w-4 text-neutral-500" />
							<span
								className={`text-xs ml-1 truncate ${
									isExpanded
										? "text-neutral-300"
										: "text-neutral-400"
								}`}
							>
								{item.name}
							</span>

							{/* Folder actions (visible on hover) */}
							<div className="opacity-0 group-hover:opacity-100 flex ml-auto mr-1">
								<DropdownMenu>
									<DropdownMenuTrigger asChild>
										<Button
											variant="ghost"
											size="icon"
											className="h-5 w-5 p-0 text-neutral-500 hover:bg-neutral-700 hover:text-neutral-300"
											onClick={(e) => e.stopPropagation()}
										>
											<PlusIcon className="h-3 w-3" />
										</Button>
									</DropdownMenuTrigger>
									<DropdownMenuContent
										align="end"
										className="bg-neutral-900 border-neutral-800 rounded-none shadow-md"
									>
										<DropdownMenuItem
											className="text-xs text-neutral-300 hover:bg-neutral-800 focus:bg-neutral-800"
											onClick={(e) => {
												e.stopPropagation();
												setSelectedFolder(item.path);
												setIsCreatingFile(true);
											}}
										>
											<FilePlusIcon className="h-3.5 w-3.5 mr-2" />
											New File
										</DropdownMenuItem>
										<DropdownMenuItem
											className="text-xs text-neutral-300 hover:bg-neutral-800 focus:bg-neutral-800"
											onClick={(e) => {
												e.stopPropagation();
												setSelectedFolder(item.path);
												setIsCreatingFolder(true);
											}}
										>
											<FolderPlusIcon className="h-3.5 w-3.5 mr-2" />
											New Folder
										</DropdownMenuItem>
									</DropdownMenuContent>
								</DropdownMenu>

								<Button
									variant="ghost"
									size="icon"
									className="h-5 w-5 p-0 ml-0.5 text-neutral-500 hover:bg-neutral-700 hover:text-neutral-300"
									onClick={(e) => {
										e.stopPropagation();
										refreshFolder(item.path);
									}}
								>
									<RefreshCwIcon className="h-3 w-3" />
								</Button>
							</div>
						</div>

						{isExpanded && item.children && (
							<div className="folder-children">
								{renderFolderItems(item.children, level + 1)}
							</div>
						)}
					</div>
				);
			} else {
				return (
					<div
						key={item.path}
						className={`flex items-center h-6 cursor-pointer ${
							isActive
								? "bg-blue-900/30"
								: "hover:bg-neutral-800/40"
						}`}
						onClick={() => handleFileClick(item)}
						style={{ paddingLeft: `${indent + 22}px` }}
					>
						{renderFileIcon(item.name)}
						<span
							className={`text-xs ml-1 truncate ${
								isActive ? "text-white" : "text-neutral-400"
							}`}
						>
							{item.name}
						</span>
					</div>
				);
			}
		});
	};

	return (
		<div className="flex flex-col h-full select-none bg-neutral-900 text-neutral-400">
			{/* Explorer header */}
			<div className="px-4 pt-2 pb-1">
				<h2 className="text-xs font-semibold uppercase tracking-wider text-neutral-500">
					Explorer
				</h2>
			</div>

			{/* Actions bar */}
			<div className="px-2 pb-1 flex items-center justify-end gap-1">
				{currentDirectory && (
					<Button
						variant="ghost"
						size="icon"
						className="h-5 w-5 p-0 text-neutral-500 hover:text-neutral-300 hover:bg-neutral-800"
						onClick={() => refreshFolder(currentDirectory)}
						title="Refresh"
						disabled={isLoading}
					>
						<RefreshCwIcon
							className={`h-3.5 w-3.5 ${
								isLoading ? "animate-spin" : ""
							}`}
						/>
					</Button>
				)}

				{currentDirectory && (
					<DropdownMenu>
						<DropdownMenuTrigger asChild>
							<Button
								variant="ghost"
								size="icon"
								className="h-5 w-5 p-0 text-neutral-500 hover:text-neutral-300 hover:bg-neutral-800"
								title="New..."
							>
								<PlusIcon className="h-3.5 w-3.5" />
							</Button>
						</DropdownMenuTrigger>
						<DropdownMenuContent
							align="end"
							className="bg-neutral-900 border-neutral-800 rounded-none shadow-md"
						>
							<DropdownMenuItem
								className="text-xs text-neutral-300 hover:bg-neutral-800 focus:bg-neutral-800"
								onClick={() => {
									setSelectedFolder(currentDirectory);
									setIsCreatingFile(true);
								}}
							>
								<FilePlusIcon className="h-3.5 w-3.5 mr-2" />
								New File
							</DropdownMenuItem>
							<DropdownMenuItem
								className="text-xs text-neutral-300 hover:bg-neutral-800 focus:bg-neutral-800"
								onClick={() => {
									setSelectedFolder(currentDirectory);
									setIsCreatingFolder(true);
								}}
							>
								<FolderPlusIcon className="h-3.5 w-3.5 mr-2" />
								New Folder
							</DropdownMenuItem>
						</DropdownMenuContent>
					</DropdownMenu>
				)}

				<Button
					variant="ghost"
					size="sm"
					className="h-5 px-2 text-xs text-neutral-500 hover:text-neutral-300 hover:bg-neutral-800"
					onClick={onDirectoryOpen}
					title="Open Folder"
				>
					Open
				</Button>
			</div>

			{/* File tree */}
			<ScrollArea className="flex-grow">
				{currentDirectory ? (
					<div className="vscode-file-explorer">
						{files.length > 0 ? (
							renderFolderItems(files)
						) : (
							<div className="py-2 px-2 text-xs text-neutral-500">
								{isLoading ? "Loading..." : "Empty folder"}
							</div>
						)}
					</div>
				) : (
					<div className="flex flex-col items-center justify-center h-full p-4 text-neutral-500">
						<p className="text-xs text-center mb-4">
							No folder open
						</p>
						<Button
							variant="outline"
							size="sm"
							className="bg-neutral-800 border-neutral-700 hover:bg-neutral-700 text-neutral-300 text-xs h-7 px-2"
							onClick={onDirectoryOpen}
						>
							Open Folder
						</Button>
					</div>
				)}
			</ScrollArea>

			{/* File creation dialog */}
			<Dialog open={isCreatingFile} onOpenChange={setIsCreatingFile}>
				<DialogContent className="bg-neutral-900 border-neutral-800 shadow-xl rounded-sm text-neutral-300">
					<DialogHeader>
						<DialogTitle className="text-neutral-200">
							Create New File
						</DialogTitle>
						<DialogDescription className="text-neutral-400 text-xs">
							Enter the file name to create in the selected
							folder.
						</DialogDescription>
					</DialogHeader>

					<div className="py-4">
						<Label
							htmlFor="fileName"
							className="text-neutral-300 text-xs"
						>
							File name
						</Label>
						<Input
							id="fileName"
							value={newFileName}
							onChange={(e) => setNewFileName(e.target.value)}
							placeholder="example.txt"
							className="mt-2 bg-neutral-800 border-neutral-700 text-neutral-200 text-xs"
							onKeyDown={(e) => {
								if (e.key === "Enter") {
									handleCreateFile();
								}
							}}
						/>
					</div>

					<DialogFooter>
						<Button
							variant="secondary"
							onClick={() => setIsCreatingFile(false)}
							disabled={isLoading}
							className="bg-neutral-800 hover:bg-neutral-700 text-neutral-300 text-xs h-7"
						>
							Cancel
						</Button>
						<Button
							onClick={handleCreateFile}
							disabled={!newFileName.trim() || isLoading}
							className="bg-blue-700 hover:bg-blue-600 text-white text-xs h-7"
						>
							{isLoading ? "Creating..." : "Create"}
						</Button>
					</DialogFooter>
				</DialogContent>
			</Dialog>

			{/* Folder creation dialog */}
			<Dialog open={isCreatingFolder} onOpenChange={setIsCreatingFolder}>
				<DialogContent className="bg-neutral-900 border-neutral-800 shadow-xl rounded-sm text-neutral-300">
					<DialogHeader>
						<DialogTitle className="text-neutral-200">
							Create New Folder
						</DialogTitle>
						<DialogDescription className="text-neutral-400 text-xs">
							Enter the folder name to create.
						</DialogDescription>
					</DialogHeader>

					<div className="py-4">
						<Label
							htmlFor="folderName"
							className="text-neutral-300 text-xs"
						>
							Folder name
						</Label>
						<Input
							id="folderName"
							value={newFolderName}
							onChange={(e) => setNewFolderName(e.target.value)}
							placeholder="new-folder"
							className="mt-2 bg-neutral-800 border-neutral-700 text-neutral-200 text-xs"
							onKeyDown={(e) => {
								if (e.key === "Enter") {
									handleCreateFolder();
								}
							}}
						/>
					</div>

					<DialogFooter>
						<Button
							variant="secondary"
							onClick={() => setIsCreatingFolder(false)}
							disabled={isLoading}
							className="bg-neutral-800 hover:bg-neutral-700 text-neutral-300 text-xs h-7"
						>
							Cancel
						</Button>
						<Button
							onClick={handleCreateFolder}
							disabled={!newFolderName.trim() || isLoading}
							className="bg-blue-700 hover:bg-blue-600 text-white text-xs h-7"
						>
							{isLoading ? "Creating..." : "Create"}
						</Button>
					</DialogFooter>
				</DialogContent>
			</Dialog>

			{/* Optional: Add status bar for even more VSCode-like appearance */}
			<div className="h-5 bg-blue-900/80 text-blue-100 flex items-center px-2 text-xs">
				<span>{currentDirectory ? `${files.length} items` : ""}</span>
			</div>
		</div>
	);
}
